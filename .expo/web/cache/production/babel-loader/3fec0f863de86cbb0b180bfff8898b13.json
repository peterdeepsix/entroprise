{"ast":null,"code":"import _extends from\"@babel/runtime/helpers/extends\";import _classCallCheck from\"@babel/runtime/helpers/classCallCheck\";import _createClass from\"@babel/runtime/helpers/createClass\";import _possibleConstructorReturn from\"@babel/runtime/helpers/possibleConstructorReturn\";import _getPrototypeOf from\"@babel/runtime/helpers/getPrototypeOf\";import _inherits from\"@babel/runtime/helpers/inherits\";import React from\"react\";import PropTypes from\"prop-types\";import loader,{PageResourceStatus}from\"./loader\";import redirects from\"./redirects.json\";import{apiRunner}from\"./api-runner-browser\";import emitter from\"./emitter\";import{RouteAnnouncerProps}from\"./route-announcer-props\";import{navigate as reachNavigate}from\"@reach/router\";import{globalHistory}from\"@reach/router/lib/history\";import{parsePath}from\"gatsby-link\";var redirectMap=redirects.reduce(function(map,redirect){map[redirect.fromPath]=redirect;return map;},{});function maybeRedirect(pathname){var redirect=redirectMap[pathname];if(redirect!=null){if(process.env.NODE_ENV!==\"production\"){var pageResources=loader.loadPageSync(pathname);if(pageResources!=null){console.error(\"The route \\\"\"+pathname+\"\\\" matches both a page and a redirect; this is probably not intentional.\");}}window.___replace(redirect.toPath);return true;}else{return false;}}var onPreRouteUpdate=function onPreRouteUpdate(location,prevLocation){if(!maybeRedirect(location.pathname)){apiRunner(\"onPreRouteUpdate\",{location:location,prevLocation:prevLocation});}};var onRouteUpdate=function onRouteUpdate(location,prevLocation){if(!maybeRedirect(location.pathname)){apiRunner(\"onRouteUpdate\",{location:location,prevLocation:prevLocation});}};var navigate=function navigate(to){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var _parsePath=parsePath(to),pathname=_parsePath.pathname;var redirect=redirectMap[pathname];if(redirect){to=redirect.toPath;pathname=parsePath(to).pathname;}if(window.___swUpdated){window.location=pathname;return;}var timeoutId=setTimeout(function(){emitter.emit(\"onDelayedLoadPageResources\",{pathname:pathname});apiRunner(\"onRouteUpdateDelayed\",{location:window.location});},1000);loader.loadPage(pathname).then(function(pageResources){if(!pageResources||pageResources.status===PageResourceStatus.Error){window.history.replaceState({},\"\",location.href);window.location=pathname;clearTimeout(timeoutId);return;}if(process.env.NODE_ENV===\"production\"&&pageResources){if(pageResources.page.webpackCompilationHash!==window.___webpackCompilationHash){if(\"serviceWorker\"in navigator&&navigator.serviceWorker.controller!==null&&navigator.serviceWorker.controller.state===\"activated\"){navigator.serviceWorker.controller.postMessage({gatsbyApi:\"clearPathResources\"});}console.log(\"Site has changed on server. Reloading browser\");window.location=pathname;}}reachNavigate(to,options);clearTimeout(timeoutId);});};function shouldUpdateScroll(prevRouterProps,_ref){var _this=this;var location=_ref.location;var pathname=location.pathname,hash=location.hash;var results=apiRunner(\"shouldUpdateScroll\",{prevRouterProps:prevRouterProps,pathname:pathname,routerProps:{location:location},getSavedScrollPosition:function getSavedScrollPosition(args){return _this._stateStorage.read(args);}});if(results.length>0){return results[results.length-1];}if(prevRouterProps){var oldPathname=prevRouterProps.location.pathname;if(oldPathname===pathname){return hash?decodeURI(hash.slice(1)):[0,0];}}return true;}function init(){globalHistory.listen(function(args){args.location.action=args.action;});window.___push=function(to){return navigate(to,{replace:false});};window.___replace=function(to){return navigate(to,{replace:true});};window.___navigate=function(to,options){return navigate(to,options);};maybeRedirect(window.location.pathname);}var RouteAnnouncer=function(_React$Component){_inherits(RouteAnnouncer,_React$Component);function RouteAnnouncer(props){var _this2;_classCallCheck(this,RouteAnnouncer);_this2=_possibleConstructorReturn(this,_getPrototypeOf(RouteAnnouncer).call(this,props));_this2.announcementRef=React.createRef();return _this2;}_createClass(RouteAnnouncer,[{key:\"componentDidUpdate\",value:function componentDidUpdate(prevProps,nextProps){var _this3=this;requestAnimationFrame(function(){var pageName=\"new page at \"+_this3.props.location.pathname;if(document.title){pageName=document.title;}var pageHeadings=document.getElementById(\"gatsby-focus-wrapper\").getElementsByTagName(\"h1\");if(pageHeadings&&pageHeadings.length){pageName=pageHeadings[0].textContent;}var newAnnouncement=\"Navigated to \"+pageName;var oldAnnouncement=_this3.announcementRef.current.innerText;if(oldAnnouncement!==newAnnouncement){_this3.announcementRef.current.innerText=newAnnouncement;}});}},{key:\"render\",value:function render(){return React.createElement(\"div\",_extends({},RouteAnnouncerProps,{ref:this.announcementRef}));}}]);return RouteAnnouncer;}(React.Component);var RouteUpdates=function(_React$Component2){_inherits(RouteUpdates,_React$Component2);function RouteUpdates(props){var _this4;_classCallCheck(this,RouteUpdates);_this4=_possibleConstructorReturn(this,_getPrototypeOf(RouteUpdates).call(this,props));onPreRouteUpdate(props.location,null);return _this4;}_createClass(RouteUpdates,[{key:\"componentDidMount\",value:function componentDidMount(){onRouteUpdate(this.props.location,null);}},{key:\"componentDidUpdate\",value:function componentDidUpdate(prevProps,prevState,shouldFireRouteUpdate){if(shouldFireRouteUpdate){onRouteUpdate(this.props.location,prevProps.location);}}},{key:\"getSnapshotBeforeUpdate\",value:function getSnapshotBeforeUpdate(prevProps){if(this.props.location.pathname!==prevProps.location.pathname){onPreRouteUpdate(this.props.location,prevProps.location);return true;}return false;}},{key:\"render\",value:function render(){return React.createElement(React.Fragment,null,this.props.children,React.createElement(RouteAnnouncer,{location:location}));}}]);return RouteUpdates;}(React.Component);RouteUpdates.propTypes={location:PropTypes.object.isRequired};export{init,shouldUpdateScroll,RouteUpdates};","map":{"version":3,"sources":["C:/Users/arnol/code/entroprise/.cache/navigation.js"],"names":["React","PropTypes","loader","PageResourceStatus","redirects","apiRunner","emitter","RouteAnnouncerProps","navigate","reachNavigate","globalHistory","parsePath","redirectMap","reduce","map","redirect","fromPath","maybeRedirect","pathname","process","env","NODE_ENV","pageResources","loadPageSync","console","error","window","___replace","toPath","onPreRouteUpdate","location","prevLocation","onRouteUpdate","to","options","___swUpdated","timeoutId","setTimeout","emit","loadPage","then","status","Error","history","replaceState","href","clearTimeout","page","webpackCompilationHash","___webpackCompilationHash","navigator","serviceWorker","controller","state","postMessage","gatsbyApi","log","shouldUpdateScroll","prevRouterProps","hash","results","routerProps","getSavedScrollPosition","args","_stateStorage","read","length","oldPathname","decodeURI","slice","init","listen","action","___push","replace","___navigate","RouteAnnouncer","props","announcementRef","createRef","prevProps","nextProps","requestAnimationFrame","pageName","document","title","pageHeadings","getElementById","getElementsByTagName","textContent","newAnnouncement","oldAnnouncement","current","innerText","Component","RouteUpdates","prevState","shouldFireRouteUpdate","children","propTypes","object","isRequired"],"mappings":"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","sourcesContent":["import React from \"react\"\nimport PropTypes from \"prop-types\"\nimport loader, { PageResourceStatus } from \"./loader\"\nimport redirects from \"./redirects.json\"\nimport { apiRunner } from \"./api-runner-browser\"\nimport emitter from \"./emitter\"\nimport { RouteAnnouncerProps } from \"./route-announcer-props\"\nimport { navigate as reachNavigate } from \"@reach/router\"\nimport { globalHistory } from \"@reach/router/lib/history\"\nimport { parsePath } from \"gatsby-link\"\n\n// Convert to a map for faster lookup in maybeRedirect()\nconst redirectMap = redirects.reduce((map, redirect) => {\n  map[redirect.fromPath] = redirect\n  return map\n}, {})\n\nfunction maybeRedirect(pathname) {\n  const redirect = redirectMap[pathname]\n\n  if (redirect != null) {\n    if (process.env.NODE_ENV !== `production`) {\n      const pageResources = loader.loadPageSync(pathname)\n\n      if (pageResources != null) {\n        console.error(\n          `The route \"${pathname}\" matches both a page and a redirect; this is probably not intentional.`\n        )\n      }\n    }\n\n    window.___replace(redirect.toPath)\n    return true\n  } else {\n    return false\n  }\n}\n\nconst onPreRouteUpdate = (location, prevLocation) => {\n  if (!maybeRedirect(location.pathname)) {\n    apiRunner(`onPreRouteUpdate`, { location, prevLocation })\n  }\n}\n\nconst onRouteUpdate = (location, prevLocation) => {\n  if (!maybeRedirect(location.pathname)) {\n    apiRunner(`onRouteUpdate`, { location, prevLocation })\n  }\n}\n\nconst navigate = (to, options = {}) => {\n  let { pathname } = parsePath(to)\n  const redirect = redirectMap[pathname]\n\n  // If we're redirecting, just replace the passed in pathname\n  // to the one we want to redirect to.\n  if (redirect) {\n    to = redirect.toPath\n    pathname = parsePath(to).pathname\n  }\n\n  // If we had a service worker update, no matter the path, reload window and\n  // reset the pathname whitelist\n  if (window.___swUpdated) {\n    window.location = pathname\n    return\n  }\n\n  // Start a timer to wait for a second before transitioning and showing a\n  // loader in case resources aren't around yet.\n  const timeoutId = setTimeout(() => {\n    emitter.emit(`onDelayedLoadPageResources`, { pathname })\n    apiRunner(`onRouteUpdateDelayed`, {\n      location: window.location,\n    })\n  }, 1000)\n\n  loader.loadPage(pathname).then(pageResources => {\n    // If no page resources, then refresh the page\n    // Do this, rather than simply `window.location.reload()`, so that\n    // pressing the back/forward buttons work - otherwise when pressing\n    // back, the browser will just change the URL and expect JS to handle\n    // the change, which won't always work since it might not be a Gatsby\n    // page.\n    if (!pageResources || pageResources.status === PageResourceStatus.Error) {\n      window.history.replaceState({}, ``, location.href)\n      window.location = pathname\n      clearTimeout(timeoutId)\n      return\n    }\n\n    // If the loaded page has a different compilation hash to the\n    // window, then a rebuild has occurred on the server. Reload.\n    if (process.env.NODE_ENV === `production` && pageResources) {\n      if (\n        pageResources.page.webpackCompilationHash !==\n        window.___webpackCompilationHash\n      ) {\n        // Purge plugin-offline cache\n        if (\n          `serviceWorker` in navigator &&\n          navigator.serviceWorker.controller !== null &&\n          navigator.serviceWorker.controller.state === `activated`\n        ) {\n          navigator.serviceWorker.controller.postMessage({\n            gatsbyApi: `clearPathResources`,\n          })\n        }\n\n        console.log(`Site has changed on server. Reloading browser`)\n        window.location = pathname\n      }\n    }\n    reachNavigate(to, options)\n    clearTimeout(timeoutId)\n  })\n}\n\nfunction shouldUpdateScroll(prevRouterProps, { location }) {\n  const { pathname, hash } = location\n  const results = apiRunner(`shouldUpdateScroll`, {\n    prevRouterProps,\n    // `pathname` for backwards compatibility\n    pathname,\n    routerProps: { location },\n    getSavedScrollPosition: args => this._stateStorage.read(args),\n  })\n  if (results.length > 0) {\n    // Use the latest registered shouldUpdateScroll result, this allows users to override plugin's configuration\n    // @see https://github.com/gatsbyjs/gatsby/issues/12038\n    return results[results.length - 1]\n  }\n\n  if (prevRouterProps) {\n    const {\n      location: { pathname: oldPathname },\n    } = prevRouterProps\n    if (oldPathname === pathname) {\n      // Scroll to element if it exists, if it doesn't, or no hash is provided,\n      // scroll to top.\n      return hash ? decodeURI(hash.slice(1)) : [0, 0]\n    }\n  }\n  return true\n}\n\nfunction init() {\n  // The \"scroll-behavior\" package expects the \"action\" to be on the location\n  // object so let's copy it over.\n  globalHistory.listen(args => {\n    args.location.action = args.action\n  })\n\n  window.___push = to => navigate(to, { replace: false })\n  window.___replace = to => navigate(to, { replace: true })\n  window.___navigate = (to, options) => navigate(to, options)\n\n  // Check for initial page-load redirect\n  maybeRedirect(window.location.pathname)\n}\n\nclass RouteAnnouncer extends React.Component {\n  constructor(props) {\n    super(props)\n    this.announcementRef = React.createRef()\n  }\n\n  componentDidUpdate(prevProps, nextProps) {\n    requestAnimationFrame(() => {\n      let pageName = `new page at ${this.props.location.pathname}`\n      if (document.title) {\n        pageName = document.title\n      }\n      const pageHeadings = document\n        .getElementById(`gatsby-focus-wrapper`)\n        .getElementsByTagName(`h1`)\n      if (pageHeadings && pageHeadings.length) {\n        pageName = pageHeadings[0].textContent\n      }\n      const newAnnouncement = `Navigated to ${pageName}`\n      const oldAnnouncement = this.announcementRef.current.innerText\n      if (oldAnnouncement !== newAnnouncement) {\n        this.announcementRef.current.innerText = newAnnouncement\n      }\n    })\n  }\n\n  render() {\n    return <div {...RouteAnnouncerProps} ref={this.announcementRef}></div>\n  }\n}\n\n// Fire on(Pre)RouteUpdate APIs\nclass RouteUpdates extends React.Component {\n  constructor(props) {\n    super(props)\n    onPreRouteUpdate(props.location, null)\n  }\n\n  componentDidMount() {\n    onRouteUpdate(this.props.location, null)\n  }\n\n  componentDidUpdate(prevProps, prevState, shouldFireRouteUpdate) {\n    if (shouldFireRouteUpdate) {\n      onRouteUpdate(this.props.location, prevProps.location)\n    }\n  }\n\n  getSnapshotBeforeUpdate(prevProps) {\n    if (this.props.location.pathname !== prevProps.location.pathname) {\n      onPreRouteUpdate(this.props.location, prevProps.location)\n      return true\n    }\n\n    return false\n  }\n\n  render() {\n    return (\n      <React.Fragment>\n        {this.props.children}\n        <RouteAnnouncer location={location} />\n      </React.Fragment>\n    )\n  }\n}\n\nRouteUpdates.propTypes = {\n  location: PropTypes.object.isRequired,\n}\n\nexport { init, shouldUpdateScroll, RouteUpdates }\n"]},"metadata":{},"sourceType":"module"}